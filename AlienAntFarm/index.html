<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Alien Ant Farm's BioHive prototype. Command the swarm directly in the browser." />
  <meta name="theme-color" content="#050b0f" />
  <title>Alien Ant Farm | BioHive Prototype</title>
  <link rel="icon" href="Ant.png" type="image/png" />
  <style>
    :root {
      color-scheme: dark;
      --bg: #03070a;
      --panel-bg: rgba(4, 9, 12, 0.78);
      --panel-border: rgba(215, 247, 255, 0.22);
      --text: #def6ff;
      --muted: rgba(222, 246, 255, 0.75);
      --accent: #7dffe1;
      font-family: 'Space Grotesk', 'Inter', 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      overflow: hidden;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      image-rendering: pixelated;
      background: #050b0f;
      z-index: 0;
    }
    .site-header {
      position: fixed;
      left: clamp(12px, 2vw, 42px);
      top: clamp(10px, 2vw, 32px);
      z-index: 3;
      padding: 18px 22px;
      border-radius: 18px;
      border: 1px solid var(--panel-border);
      background: var(--panel-bg);
      backdrop-filter: blur(18px);
      width: min(420px, calc(100vw - 24px));
    }
    .site-title {
      margin: 0 0 14px;
    }
    .site-title h1 {
      margin: 4px 0 0;
      font-size: clamp(1.4rem, 2vw, 1.8rem);
    }
    .eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.2em;
      font-size: 0.65rem;
      color: var(--muted);
      margin: 0;
    }
    .header-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .btn {
      border: 1px solid transparent;
      background: var(--accent);
      color: #021512;
      font-weight: 600;
      padding: 8px 16px;
      border-radius: 999px;
      cursor: pointer;
      transition: transform 150ms ease, box-shadow 150ms ease;
    }
    .btn:active { transform: translateY(1px); }
    .ghost-link {
      color: var(--text);
      text-decoration: none;
      border-bottom: 1px solid rgba(125, 255, 225, 0.4);
      padding-bottom: 2px;
      align-self: flex-end;
      font-size: 0.9rem;
    }
    .ui-stack {
      position: fixed;
      left: clamp(12px, 2vw, 42px);
      top: clamp(152px, 16vh, 200px);
      width: min(400px, calc(100vw - 24px));
      max-height: calc(100vh - 220px);
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 14px;
      padding-right: 6px;
      z-index: 2;
    }
    .panel {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 18px;
      padding: 18px 20px;
      backdrop-filter: blur(16px);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
    }
    .panel--alt { border-style: dashed; }
    .panel__title {
      margin: 0 0 8px;
      font-size: 1.05rem;
    }
    .panel__hint {
      margin: 12px 0 0;
      color: var(--muted);
      font-size: 0.85rem;
    }
    .hud {
      font: 0.9rem/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color: var(--text);
      min-height: 72px;
    }
    .keymap {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.95rem;
    }
    .keymap li {
      display: flex;
      justify-content: space-between;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      padding: 4px 0;
    }
    .site-footer {
      position: fixed;
      left: clamp(12px, 2vw, 42px);
      bottom: clamp(12px, 2vw, 32px);
      z-index: 3;
      color: var(--muted);
      font-size: 0.85rem;
      max-width: min(420px, calc(100vw - 24px));
    }
    .noscript {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.9);
      z-index: 4;
      font-size: 1.1rem;
    }
    @media (max-width: 720px) {
      body { overflow-y: auto; }
      canvas { position: fixed; }
      .site-header,
      .ui-stack,
      .site-footer {
        position: relative;
        width: auto;
        left: auto;
        right: auto;
        top: auto;
        bottom: auto;
        margin: 12px auto;
      }
      .ui-stack { max-height: none; }
      .site-footer { text-align: center; }
    }
  </style>
</head>
<body>
  <canvas id="game-canvas" aria-hidden="true"></canvas>
  <header class="site-header">
    <div class="site-title">
      <p class="eyebrow">Alien Ant Farm</p>
      <h1>BioHive Prototype</h1>
      <p class="subtitle">Self-contained HTML5 build ready for GitHub Pages hosting.</p>
    </div>
    <div class="header-actions">
      <button class="btn" type="button" id="reset-run">Reset Run</button>
      <a class="ghost-link" href="https://github.com/polerixsys/AlienAntFarm" target="_blank" rel="noopener">View repository</a>
    </div>
  </header>
  <main class="ui-stack" aria-label="Interface overlays">
    <section class="panel">
      <h2 class="panel__title">Mission Feed</h2>
      <div class="hud" id="hud-panel" role="status" aria-live="polite">
        <p>Booting BioHive...</p>
      </div>
    </section>
    <section class="panel" id="how-to-play">
      <h2 class="panel__title">How to Play</h2>
      <ul class="keymap">
        <li><span>WASD / Arrows</span><span>Move</span></li>
        <li><span>E key</span><span>Pick up / drop creature</span></li>
        <li><span>Space</span><span>Drop carried creature</span></li>
        <li><span>Right click</span><span>Place resin</span></li>
        <li><span>R key</span><span>Reset simulation</span></li>
        <li><span>Escort mealworms</span><span>Pen them on resin</span></li>
      </ul>
      <p class="panel__hint">Keep the resin chain connected to the nest or it will decay.</p>
    </section>
    <section class="panel panel--alt" id="about">
      <h2 class="panel__title">About this Build</h2>
      <p>Everything runs locally in the browser &mdash; perfect for GitHub Pages or any static host.</p>
      <p>Mealworms now roam the map: escort them onto connected resin to set up illuminated pens that drip biomass-rich milk. Drones will pitch in automatically once host targets are scarce.</p>
      <p class="panel__hint">All audio/visual assets here are placeholders so you can reskin freely.</p>
    </section>
  </main>
  <footer class="site-footer">
    <p>&copy; <span id="year"></span> Alien Ant Farm. Deploy the swarm anywhere static HTML is supported.</p>
  </footer>
  <noscript class="noscript">Enable JavaScript to command the colony.</noscript>
  <script type="module">
const yearLabel = document.getElementById('year');
if (yearLabel) yearLabel.textContent = new Date().getFullYear();

const bioHive = (() => {
  // ----------------------------
  // BioHive: original prototype
  // ----------------------------
  // Controls:
  //  - WASD / Arrow keys: move
  //  - E: pick up / drop a nearby host
  //  - Right click: place resin tile (costs biomass, must be adjacent to connected resin)
  //  - Space: drop carried host (where you stand)
  //  - R: reset
  //
  // Goal:
  //  - Keep the hive connected, harvest biomass, survive patrol spawns.

  const canvas = document.getElementById('game-canvas');
  const hudEl = document.getElementById('hud-panel');
  if (!canvas || !hudEl) {
    throw new Error('BioHive UI elements are missing from the document.');
  }
  const ctx = canvas.getContext('2d', { alpha: false });

  const DPR = Math.max(1, Math.min(2, devicePixelRatio || 1));

  function resize() {
    canvas.width  = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
  }
  addEventListener('resize', resize, { passive:true });
  resize();

  // World
  const TILE = 20;               // world tile size in pixels (world units)
  const W = 90, H = 60;          // map size in tiles
  const T_EMPTY = 0, T_WALL = 1, T_RESIN = 2;

  // Gameplay tuning
  const MOVE_SPEED = 240;        // pixels per second
  const CARRY_SLOW = 0.62;
  const RESIN_COST = 2;
  const EGG_COST = 6;            // biomass to auto-spawn an egg at nest (via drop-off)
  const EGG_HATCH_SEC = 7.5;
  const HOST_VALUE = 6;          // biomass gained per host processed
  const MARINE_SPAWN_EVERY = 18; // seconds
  const CONNECT_DECAY_SEC = 9;   // disconnected resin decays into empty over time

  // RNG helpers
  const rnd = (a=1,b=0) => Math.random()*(a-b)+b;
  const irnd = (a,b=0) => Math.floor(rnd(a,b));

  // Grid
  let grid, resinAge, connected; // connected marks resin connected to nest

  function idx(x,y){ return y*W + x; }
  function inb(x,y){ return x>=0 && y>=0 && x<W && y<H; }

  // Entities
  let t = 0, dt = 0, last = performance.now();
  let camera = { x: 0, y: 0 };

  let biomass = 8;
  let eggs = [];     // {x,y, hatchAt}
  let drones = [];   // {x,y, vx,vy, carryHostId:null|number, carryMealwormId:null|number}
  let hosts = [];    // {x,y, vx,vy, alive, grabbedBy:null|('player'|'drone:'+i)}
  let mealworms = []; // {x,y,vx,vy, captured:boolean, penX,penY, grabbedBy:null|'player'|'drone:k', milkTimer, alive}
  let marines = [];  // {x,y, vx,vy, shootCd}
  let kills = 0;
  let mealwormMilk = 0;
  let daylightLevel = 0;

  // Nest is a small connected resin patch at start
  const nest = { x: Math.floor(W/2), y: Math.floor(H/2), r: 3 };

  // Player
  const player = { x: (nest.x+0.5)*TILE, y: (nest.y+0.5)*TILE, vx:0, vy:0, carrying: null };

  // Input
  const keys = new Set();
  addEventListener('keydown', (e) => {
    if (e.repeat) return;
    keys.add(e.key.toLowerCase());
    if (e.key.toLowerCase() === 'r') init();
    if (e.key.toLowerCase() === 'e') tryPickupOrDrop();
  });
  addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

  // Mouse
  let mouse = { x: 0, y: 0, down:false, rdown:false };
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * DPR;
    mouse.y = (e.clientY - rect.top) * DPR;
  }, { passive:true });

  canvas.addEventListener('contextmenu', (e) => e.preventDefault());
  canvas.addEventListener('mousedown', (e) => {
    if (e.button === 2) {
      placeResinAtMouse();
    }
  });

  function worldFromScreen(sx, sy) {
    return { x: sx/DPR + camera.x, y: sy/DPR + camera.y };
  }

  // Init / reset
  function init() {
    t = 0; biomass = 8; eggs = []; drones = []; hosts = []; marines = []; kills = 0;
    mealworms = [];
    mealwormMilk = 0;
    grid = new Uint8Array(W*H);
    resinAge = new Float32Array(W*H);
    connected = new Uint8Array(W*H);

    // Carve map: walls around edges + some random boulders
    for (let y=0; y<H; y++){
      for (let x=0; x<W; x++){
        let v = T_EMPTY;
        if (x===0 || y===0 || x===W-1 || y===H-1) v = T_WALL;
        if (Math.random() < 0.06) v = T_WALL;
        grid[idx(x,y)] = v;
      }
    }

    // Clear area near nest
    for (let y=nest.y-7; y<=nest.y+7; y++){
      for (let x=nest.x-7; x<=nest.x+7; x++){
        if (inb(x,y)) grid[idx(x,y)] = T_EMPTY;
      }
    }

    // Seed connected resin nest blob
    for (let y=nest.y-nest.r; y<=nest.y+nest.r; y++){
      for (let x=nest.x-nest.r; x<=nest.x+nest.r; x++){
        if (!inb(x,y)) continue;
        const dx=x-nest.x, dy=y-nest.y;
        if (dx*dx+dy*dy <= nest.r*nest.r+0.5) grid[idx(x,y)] = T_RESIN;
      }
    }

    // Spawn hosts
    const hostCount = 28;
    for (let i=0;i<hostCount;i++){
      const p = randomOpenTileFarFromNest(7);
      hosts.push({
        x: (p.x+0.5)*TILE,
        y: (p.y+0.5)*TILE,
        vx: rnd(28,-28),
        vy: rnd(28,-28),
        alive: true,
        grabbedBy: null
      });
    }

    // Mealworms roaming surface in search of light
    const mealwormCount = 10;
    for (let i=0; i<mealwormCount; i++) {
      const p = randomOpenTileFarFromNest(10);
      mealworms.push({
        x: (p.x+0.5)*TILE,
        y: (p.y+0.5)*TILE,
        vx: rnd(18,-18),
        vy: rnd(18,-18),
        captured: false,
        penX: null,
        penY: null,
        milkTimer: rnd(9, 5),
        alive: true,
        grabbedBy: null
      });
    }

    // Player at nest
    player.x = (nest.x+0.5)*TILE;
    player.y = (nest.y+0.5)*TILE;
    player.vx = 0; player.vy = 0;
    player.carrying = null;

    // Initial connectivity calc
    recomputeConnectivity();
  }

  function randomOpenTileFarFromNest(minDistTiles) {
    for (let tries=0; tries<5000; tries++){
      const x = irnd(W-2,1), y = irnd(H-2,1);
      if (grid[idx(x,y)] !== T_EMPTY) continue;
      const dx = x - nest.x, dy = y - nest.y;
      if (dx*dx + dy*dy < minDistTiles*minDistTiles) continue;
      return {x,y};
    }
    return {x: 2, y: 2};
  }

  // Connectivity: BFS from nest through resin
  function recomputeConnectivity() {
    connected.fill(0);
    const qx = new Int16Array(W*H);
    const qy = new Int16Array(W*H);
    let qh=0, qt=0;

    // Start positions: all resin tiles in nest radius
    // Easier: pick nest tile itself if resin, else any adjacent resin
    let sx = nest.x, sy = nest.y;
    if (grid[idx(sx,sy)] !== T_RESIN) {
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (const [dx,dy] of dirs){
        const nx=sx+dx, ny=sy+dy;
        if (inb(nx,ny) && grid[idx(nx,ny)]===T_RESIN){ sx=nx; sy=ny; break; }
      }
    }
    if (grid[idx(sx,sy)] !== T_RESIN) return;

    qx[qt]=sx; qy[qt]=sy; qt++;
    connected[idx(sx,sy)] = 1;

    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    while (qh<qt){
      const x = qx[qh], y = qy[qh]; qh++;
      for (const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if (!inb(nx,ny)) continue;
        const ii = idx(nx,ny);
        if (connected[ii]) continue;
        if (grid[ii] !== T_RESIN) continue;
        connected[ii] = 1;
        qx[qt]=nx; qy[qt]=ny; qt++;
      }
    }
  }

  function isWalkableTile(tx, ty) {
    const v = grid[idx(tx,ty)];
    return v !== T_WALL;
  }

  function clampToWorld(e) {
    // Simple collision: keep inside map bounds and avoid walls by pushing out
    // Approx circle radius
    const r = 7;
    e.x = Math.max(r, Math.min(e.x, W*TILE - r));
    e.y = Math.max(r, Math.min(e.y, H*TILE - r));

    const tx = Math.floor(e.x / TILE);
    const ty = Math.floor(e.y / TILE);
    if (!inb(tx,ty)) return;

    if (grid[idx(tx,ty)] === T_WALL) {
      // push to nearest open neighbor
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (const [dx,dy] of dirs){
        const nx=tx+dx, ny=ty+dy;
        if (!inb(nx,ny)) continue;
        if (grid[idx(nx,ny)] !== T_WALL) {
          e.x = (nx+0.5)*TILE;
          e.y = (ny+0.5)*TILE;
          e.vx *= 0.25; e.vy *= 0.25;
          return;
        }
      }
    }
  }

  function dropCarriedEntityAtPlayer() {
    if (!player.carrying) return;
    const payload = player.carrying;
    if (payload.type === 'host') {
      const h = hosts[payload.id];
      if (h && h.alive) {
        h.grabbedBy = null;
        h.x = player.x + rnd(10,-10);
        h.y = player.y + rnd(10,-10);
        h.vx = player.vx * 0.2;
        h.vy = player.vy * 0.2;
      }
    } else if (payload.type === 'mealworm') {
      const mw = mealworms[payload.id];
      if (mw && mw.alive) {
        mw.grabbedBy = null;
        mw.captured = false;
        mw.penX = null;
        mw.penY = null;
        mw.x = player.x + rnd(8,-8);
        mw.y = player.y + rnd(8,-8);
        mw.vx = player.vx * 0.1;
        mw.vy = player.vy * 0.1;
      }
    }
    player.carrying = null;
  }

  function tryPickupOrDrop() {
    // If carrying, drop
    if (player.carrying !== null) {
      dropCarriedEntityAtPlayer();
      return;
    }

    // Pick nearest alive host within range
    let best = -1, bestD2 = 999999;
    for (let i=0;i<hosts.length;i++){
      const h = hosts[i];
      if (!h.alive || h.grabbedBy) continue;
      const dx=h.x-player.x, dy=h.y-player.y;
      const d2 = dx*dx+dy*dy;
      if (d2 < bestD2 && d2 < (28*28)) { bestD2 = d2; best = i; }
    }
    if (best !== -1) {
      player.carrying = { type:'host', id: best };
      hosts[best].grabbedBy = 'player';
      return;
    }

    const mwId = nearestMealworm(player.x, player.y, 32, { onlyFree: true });
    if (mwId !== -1) {
      const mw = mealworms[mwId];
      player.carrying = { type:'mealworm', id: mwId };
      mw.grabbedBy = 'player';
      mw.captured = false;
      mw.penX = null;
      mw.penY = null;
    }
  }

  function placeResinAtMouse() {
    // Place resin on the tile under mouse if rules allow
    const w = worldFromScreen(mouse.x, mouse.y);
    const tx = Math.floor(w.x / TILE);
    const ty = Math.floor(w.y / TILE);
    if (!inb(tx,ty)) return;
    const i = idx(tx,ty);

    if (grid[i] !== T_EMPTY) return;
    if (biomass < RESIN_COST) return;

    // Must be adjacent to a connected resin tile
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    let ok = false;
    for (const [dx,dy] of dirs){
      const nx=tx+dx, ny=ty+dy;
      if (!inb(nx,ny)) continue;
      const ni = idx(nx,ny);
      if (grid[ni] === T_RESIN && connected[ni] === 1) { ok = true; break; }
    }
    if (!ok) return;

    grid[i] = T_RESIN;
    resinAge[i] = 0;
    biomass -= RESIN_COST;
    recomputeConnectivity();
  }

  function spawnEggAtNest() {
    // Find a resin tile near nest to place egg on
    for (let tries=0; tries<120; tries++){
      const tx = nest.x + irnd(5,-5);
      const ty = nest.y + irnd(5,-5);
      if (!inb(tx,ty)) continue;
      if (grid[idx(tx,ty)] !== T_RESIN) continue;
      eggs.push({ x:(tx+0.5)*TILE, y:(ty+0.5)*TILE, hatchAt: t + EGG_HATCH_SEC });
      return true;
    }
    return false;
  }

  function hatchEgg(i) {
    const e = eggs[i];
    drones.push({ x:e.x, y:e.y, vx:0, vy:0, carryHostId: null, carryMealwormId: null });
    eggs.splice(i,1);
  }

  function spawnMarine() {
    // Spawn at random edge opening
    let pos = null;
    for (let tries=0; tries<800; tries++){
      const side = irnd(4,0);
      let tx=1, ty=1;
      if (side===0) { tx = 1; ty = irnd(H-2,1); }
      if (side===1) { tx = W-2; ty = irnd(H-2,1); }
      if (side===2) { ty = 1; tx = irnd(W-2,1); }
      if (side===3) { ty = H-2; tx = irnd(W-2,1); }
      if (grid[idx(tx,ty)] === T_EMPTY) { pos = {tx,ty}; break; }
    }
    if (!pos) return;
    marines.push({ x:(pos.tx+0.5)*TILE, y:(pos.ty+0.5)*TILE, vx:0, vy:0, shootCd: 0 });
  }

  // AI helpers
  function nearestHost(x,y) {
    let best=-1, bestD2=1e12;
    for (let i=0;i<hosts.length;i++){
      const h=hosts[i];
      if (!h.alive || h.grabbedBy) continue;
      const dx=h.x-x, dy=h.y-y;
      const d2=dx*dx+dy*dy;
      if (d2<bestD2){ bestD2=d2; best=i; }
    }
    return best;
  }

  function nearestMealworm(x,y,radius=Infinity,{onlyFree=true}={}) {
    let best=-1, bestD2=radius*radius;
    for (let i=0;i<mealworms.length;i++){
      const mw = mealworms[i];
      if (!mw.alive) continue;
      if (onlyFree && (mw.captured || mw.grabbedBy)) continue;
      const dx = mw.x - x, dy = mw.y - y;
      const d2 = dx*dx + dy*dy;
      if (d2 < bestD2) {
        bestD2 = d2;
        best = i;
      }
    }
    return best;
  }

  function nearestDrone(x,y) {
    let best=-1, bestD2=1e12;
    for (let i=0;i<drones.length;i++){
      const d=drones[i];
      const dx=d.x-x, dy=d.y-y;
      const d2=dx*dx+dy*dy;
      if (d2<bestD2){ bestD2=d2; best=i; }
    }
    return best;
  }

  // Main update
  let nextMarineAt = MARINE_SPAWN_EVERY;

  function update() {
    const now = performance.now();
    dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    t += dt;

    // Player input
    const up    = keys.has('w') || keys.has('arrowup');
    const down  = keys.has('s') || keys.has('arrowdown');
    const left  = keys.has('a') || keys.has('arrowleft');
    const right = keys.has('d') || keys.has('arrowright');

    let ax = (right?1:0) - (left?1:0);
    let ay = (down?1:0) - (up?1:0);
    const len = Math.hypot(ax,ay) || 1;
    ax/=len; ay/=len;

    let speed = MOVE_SPEED;
    if (player.carrying !== null) speed *= CARRY_SLOW;

    player.vx = ax * speed;
    player.vy = ay * speed;
    player.x += player.vx * dt;
    player.y += player.vy * dt;
    clampToWorld(player);

    // Carry follows player
    if (player.carrying?.type === 'host') {
      const h = hosts[player.carrying.id];
      if (h && h.alive) {
        h.x = player.x + rnd(8,-8);
        h.y = player.y + rnd(8,-8);
        h.vx = 0; h.vy = 0;
      } else {
        player.carrying = null;
      }
    } else if (player.carrying?.type === 'mealworm') {
      const mw = mealworms[player.carrying.id];
      if (mw && mw.alive) {
        mw.x = player.x + rnd(6,-6);
        mw.y = player.y + rnd(6,-6);
        mw.vx = 0; mw.vy = 0;
      } else {
        player.carrying = null;
      }
    }

    // Drop carried host instantly with Space (same as E drop but without toggling pickup)
    if (keys.has(' ')) {
      if (player.carrying !== null) {
        dropCarriedEntityAtPlayer();
        keys.delete(' ');
      }
    }

    // Hosts wander if free
    for (const h of hosts) {
      if (!h.alive) continue;
      if (h.grabbedBy) continue;

      if (Math.random() < 0.04) { h.vx += rnd(25,-25); h.vy += rnd(25,-25); }
      const s = 56;
      const vlen = Math.hypot(h.vx,h.vy) || 1;
      h.vx = (h.vx/vlen)*Math.min(vlen,s);
      h.vy = (h.vy/vlen)*Math.min(vlen,s);

      h.x += h.vx * dt;
      h.y += h.vy * dt;
      clampToWorld(h);

      // Bounce off walls gently
      const tx = Math.floor(h.x / TILE), ty = Math.floor(h.y / TILE);
      if (inb(tx,ty) && grid[idx(tx,ty)] === T_WALL) {
        h.vx *= -0.6; h.vy *= -0.6;
      }
    }

    // If player brings a host to nest resin, process it
    processDropOff('player', player.x, player.y, player.carrying);

    daylightLevel = 0.5 + 0.5 * Math.sin(t / 18);
    updateMealworms(daylightLevel);

    // Eggs hatch
    for (let i=eggs.length-1; i>=0; i--) {
      if (t >= eggs[i].hatchAt) hatchEgg(i);
    }

    // Drones behavior
    for (let i=0; i<drones.length; i++) {
      const d = drones[i];

      let targetX = d.x, targetY = d.y;
      let desiredSpeed = 170;

      if (d.carryHostId === null && d.carryMealwormId === null) {
        const hi = nearestHost(d.x, d.y);
        if (hi !== -1) {
          const h = hosts[hi];
          const dx=h.x-d.x, dy=h.y-d.y;
          const dist = Math.hypot(dx,dy);
          if (dist < 18) {
            d.carryHostId = hi;
            h.grabbedBy = 'drone:' + i;
          } else {
            targetX = h.x; targetY = h.y;
          }
        } else {
          const mi = nearestMealworm(d.x, d.y, 360, { onlyFree: true });
          if (mi !== -1) {
            const mw = mealworms[mi];
            const dx=mw.x-d.x, dy=mw.y-d.y;
            const dist = Math.hypot(dx,dy);
            if (dist < 18) {
              d.carryMealwormId = mi;
              mw.grabbedBy = 'drone:' + i;
              mw.captured = false;
              mw.penX = null;
              mw.penY = null;
            } else {
              targetX = mw.x; targetY = mw.y;
              desiredSpeed = 150;
            }
          } else {
            // idle near nest
            targetX = (nest.x+0.5)*TILE + Math.sin(t*0.8 + i)*60;
            targetY = (nest.y+0.5)*TILE + Math.cos(t*0.7 + i)*60;
          }
        }
      } else if (d.carryHostId !== null) {
        // Carrying: return to nest
        targetX = (nest.x+0.5)*TILE;
        targetY = (nest.y+0.5)*TILE;
        desiredSpeed = 150;

        const h = hosts[d.carryHostId];
        if (h && h.alive) {
          h.x = d.x + rnd(7,-7);
          h.y = d.y + rnd(7,-7);
          h.vx = 0; h.vy = 0;
        } else {
          d.carryHostId = null;
        }
      } else if (d.carryMealwormId !== null) {
        targetX = (nest.x+0.5)*TILE;
        targetY = (nest.y+0.5)*TILE;
        desiredSpeed = 145;

        const mw = mealworms[d.carryMealwormId];
        if (mw && mw.alive) {
          mw.x = d.x + rnd(5,-5);
          mw.y = d.y + rnd(5,-5);
          mw.vx = 0; mw.vy = 0;
        } else {
          d.carryMealwormId = null;
        }
      }

      const dx = targetX - d.x, dy = targetY - d.y;
      const dist = Math.hypot(dx,dy) || 1;
      const ux = dx/dist, uy = dy/dist;

      d.vx = ux * desiredSpeed;
      d.vy = uy * desiredSpeed;
      d.x += d.vx * dt;
      d.y += d.vy * dt;
      clampToWorld(d);

      // Drone drop-off processing
      if (d.carryHostId !== null) {
        processDropOff('drone', d.x, d.y, { type:'host', id: d.carryHostId }, i);
      } else if (d.carryMealwormId !== null) {
        processDropOff('drone', d.x, d.y, { type:'mealworm', id: d.carryMealwormId }, i);
      }
    }

    // Marines spawn and hunt drones
    if (t >= nextMarineAt) {
      spawnMarine();
      nextMarineAt += MARINE_SPAWN_EVERY;
    }

    for (let i=0; i<marines.length; i++) {
      const m = marines[i];
      m.shootCd = Math.max(0, m.shootCd - dt);

      // Move toward nearest connected resin tile (smells the hive)
      const goal = nearestConnectedResin(m.x, m.y) || { x:(nest.x+0.5)*TILE, y:(nest.y+0.5)*TILE };
      const dx = goal.x - m.x, dy = goal.y - m.y;
      const dist = Math.hypot(dx,dy) || 1;
      const ux = dx/dist, uy = dy/dist;

      const sp = 120;
      m.vx = ux*sp; m.vy = uy*sp;
      m.x += m.vx*dt; m.y += m.vy*dt;
      clampToWorld(m);

      // Shoot nearest drone if close
      const di = nearestDrone(m.x, m.y);
      if (di !== -1) {
        const d = drones[di];
        const ddx = d.x - m.x, ddy = d.y - m.y;
        const d2 = ddx*ddx + ddy*ddy;
        if (d2 < 220*220 && m.shootCd <= 0) {
          // remove drone
          // If it was carrying, release host
          if (d.carryHostId !== null) {
            const h = hosts[d.carryHostId];
            if (h && h.alive) h.grabbedBy = null;
          }
          if (d.carryMealwormId !== null) {
            const mw = mealworms[d.carryMealwormId];
            if (mw && mw.alive) {
              mw.grabbedBy = null;
              mw.captured = false;
              mw.penX = null;
              mw.penY = null;
            }
          }
          drones.splice(di,1);
          kills++;
          m.shootCd = 0.75;
      }
    }
  }

  function updateMealworms(daylight) {
    for (let i=0; i<mealworms.length; i++){
      const mw = mealworms[i];
      if (!mw.alive) continue;
      if (mw.grabbedBy) continue;

      if (mw.captured) {
        if (mw.penX !== null && mw.penY !== null) {
          mw.x = mw.penX + Math.sin(t * 1.6 + i) * 2.5;
          mw.y = mw.penY + Math.cos(t * 1.2 + i) * 1.5;
        }
        // Daylight drives milk production; shade starves the timer to encourage lamp-lit pens.
        mw.milkTimer -= dt * (0.5 + daylight * 1.1);
        if (mw.milkTimer <= 0) {
          mw.milkTimer = rnd(9, 5);
          const milkYield = daylight > 0.65 ? 1.4 : 0.9;
          biomass += milkYield;
          mealwormMilk += milkYield;
        }
        continue;
      }

      if (Math.random() < 0.05) {
        mw.vx += rnd(20,-20);
        mw.vy += rnd(20,-20);
      }
      const s = 40;
      const vlen = Math.hypot(mw.vx,mw.vy) || 1;
      mw.vx = (mw.vx/vlen)*Math.min(vlen,s);
      mw.vy = (mw.vy/vlen)*Math.min(vlen,s);

      mw.x += mw.vx * dt;
      mw.y += mw.vy * dt;
      clampToWorld(mw);
    }
  }

    // Resin decay if disconnected
    // Also gradually age all resin tiles
    let changed = false;
    for (let y=0;y<H;y++){
      for (let x=0;x<W;x++){
        const i = idx(x,y);
        if (grid[i] !== T_RESIN) continue;
        resinAge[i] += dt;
        if (connected[i] === 0) {
          if (resinAge[i] >= CONNECT_DECAY_SEC) {
            grid[i] = T_EMPTY;
            resinAge[i] = 0;
            changed = true;
          }
        } else {
          resinAge[i] = 0; // reset age if connected
        }
      }
    }
    if (changed) recomputeConnectivity();

    // Camera follows player
    const targetCamX = player.x - (canvas.width/DPR)/2;
    const targetCamY = player.y - (canvas.height/DPR)/2;
    camera.x += (targetCamX - camera.x) * Math.min(1, dt*7);
    camera.y += (targetCamY - camera.y) * Math.min(1, dt*7);

    // Clamp camera to world bounds
    camera.x = Math.max(0, Math.min(camera.x, W*TILE - canvas.width/DPR));
    camera.y = Math.max(0, Math.min(camera.y, H*TILE - canvas.height/DPR));

    render();
    requestAnimationFrame(update);
  }

  function nearestConnectedResin(x,y) {
    // Quick search: sample a few random resin tiles; good enough for prototype
    let best=null, bestD2=1e12;
    for (let k=0;k<90;k++){
      const tx = irnd(W-2,1), ty = irnd(H-2,1);
      const i = idx(tx,ty);
      if (grid[i] !== T_RESIN || connected[i]===0) continue;
      const cx = (tx+0.5)*TILE, cy = (ty+0.5)*TILE;
      const dx=cx-x, dy=cy-y;
      const d2=dx*dx+dy*dy;
      if (d2<bestD2){ bestD2=d2; best={x:cx,y:cy}; }
    }
    return best;
  }

  function processDropOff(by, x, y, payload, droneIndex=null) {
    if (!payload) return;

    // Must be on connected resin near nest
    const tx = Math.floor(x / TILE), ty = Math.floor(y / TILE);
    if (!inb(tx,ty)) return;
    const i = idx(tx,ty);
    if (grid[i] !== T_RESIN || connected[i] === 0) return;

    // Also within nest-ish radius
    const nx = (nest.x+0.5)*TILE, ny = (nest.y+0.5)*TILE;
    const dx = x - nx, dy = y - ny;
    if (dx*dx + dy*dy > (120*120)) return;

    if (payload.type === 'host') {
      const h = hosts[payload.id];
      if (!h || !h.alive) return;

      // Convert host to biomass, possibly spawn egg if enough biomass
      h.alive = false;
      h.grabbedBy = null;

      biomass += HOST_VALUE;

      if (biomass >= EGG_COST) {
        biomass -= EGG_COST;
        spawnEggAtNest();
      }

      // Clear carrier reference
      if (by === 'player') player.carrying = null;
      if (by === 'drone' && droneIndex !== null) {
        const d = drones[droneIndex];
        if (d) d.carryHostId = null;
      }
    } else if (payload.type === 'mealworm') {
      const mw = mealworms[payload.id];
      if (!mw || !mw.alive || mw.captured) return;
      mw.captured = true;
      mw.grabbedBy = null;
      mw.penX = (tx+0.5)*TILE;
      mw.penY = (ty+0.5)*TILE;
      mw.vx = 0;
      mw.vy = 0;
      mw.milkTimer = rnd(9, 5);

      const captureYield = daylightLevel > 0.65 ? 1.2 : 0.8;
      biomass += captureYield;
      mealwormMilk += captureYield;

      if (by === 'player') {
        player.carrying = null;
      } else if (by === 'drone' && droneIndex !== null) {
        const d = drones[droneIndex];
        if (d) d.carryMealwormId = null;
      }
    }
  }

  // Rendering
  function render() {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#061012';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // World transform
    ctx.setTransform(DPR,0,0,DPR,-camera.x*DPR,-camera.y*DPR);

    // Draw tiles
    const viewX0 = Math.floor(camera.x / TILE) - 1;
    const viewY0 = Math.floor(camera.y / TILE) - 1;
    const viewX1 = Math.floor((camera.x + canvas.width/DPR) / TILE) + 2;
    const viewY1 = Math.floor((camera.y + canvas.height/DPR) / TILE) + 2;

    for (let y=viewY0; y<=viewY1; y++){
      for (let x=viewX0; x<=viewX1; x++){
        if (!inb(x,y)) continue;
        const i = idx(x,y);
        const v = grid[i];

        if (v === T_WALL) {
          ctx.fillStyle = '#0f1b1f';
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
          ctx.fillStyle = 'rgba(255,255,255,0.04)';
          ctx.fillRect(x*TILE+2, y*TILE+2, TILE-4, TILE-4);
        } else if (v === T_EMPTY) {
          // subtle floor noise
          ctx.fillStyle = '#071416';
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        } else if (v === T_RESIN) {
          const c = connected[i] ? 1 : 0;
          ctx.fillStyle = c ? '#133332' : '#1a1a1a';
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
          ctx.fillStyle = c ? 'rgba(120,255,230,0.08)' : 'rgba(255,190,120,0.05)';
          ctx.fillRect(x*TILE+3, y*TILE+3, TILE-6, TILE-6);
        }
      }
    }

    // Nest marker
    ctx.strokeStyle = 'rgba(180,255,250,0.25)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc((nest.x+0.5)*TILE, (nest.y+0.5)*TILE, 120, 0, Math.PI*2);
    ctx.stroke();

    // Eggs
    for (const e of eggs) {
      const p = Math.max(0, Math.min(1, (e.hatchAt - t) / EGG_HATCH_SEC));
      ctx.fillStyle = `rgba(180,255,230,${0.18 + 0.55*(1-p)})`;
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, 6, 9, 0, 0, Math.PI*2);
      ctx.fill();
    }

    // Hosts
    for (const h of hosts) {
      if (!h.alive) continue;
      ctx.fillStyle = '#cdd6d8';
      ctx.beginPath();
      ctx.arc(h.x, h.y, 6, 0, Math.PI*2);
      ctx.fill();

      // Tiny direction mark
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.beginPath();
      ctx.moveTo(h.x, h.y);
      ctx.lineTo(h.x + (h.vx*0.05), h.y + (h.vy*0.05));
      ctx.stroke();
    }

    // Mealworms
    for (const mw of mealworms) {
      if (!mw.alive) continue;
      ctx.fillStyle = mw.captured ? '#ffe0a4' : '#ffb374';
      ctx.beginPath();
      ctx.ellipse(mw.x, mw.y, 5.5, 4.2, 0, 0, Math.PI*2);
      ctx.fill();
      if (mw.captured) {
        ctx.strokeStyle = 'rgba(255,224,164,0.55)';
        ctx.beginPath();
        ctx.arc(mw.x, mw.y, 8, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    // Drones
    for (const d of drones) {
      ctx.fillStyle = '#7dffe1';
      ctx.beginPath();
      ctx.arc(d.x, d.y, 7.5, 0, Math.PI*2);
      ctx.fill();

      if (d.carryHostId !== null || d.carryMealwormId !== null) {
        ctx.strokeStyle = 'rgba(125,255,225,0.35)';
        ctx.beginPath();
        ctx.arc(d.x, d.y, 13, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    // Marines
    for (const m of marines) {
      ctx.fillStyle = '#ffcf7d';
      ctx.beginPath();
      ctx.rect(m.x-6, m.y-6, 12, 12);
      ctx.fill();
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(m.x-2, m.y-7, 4, 3);
    }

    // Player
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(player.x, player.y, 9, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath();
    ctx.arc(player.x, player.y, 12, 0, Math.PI*2);
    ctx.stroke();

    if (player.carrying !== null) {
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.beginPath();
      ctx.arc(player.x, player.y, 16, 0, Math.PI*2);
      ctx.stroke();
    }

    // Build preview (right-click tile)
    const w = worldFromScreen(mouse.x, mouse.y);
    const tx = Math.floor(w.x / TILE);
    const ty = Math.floor(w.y / TILE);
    if (inb(tx,ty)) {
      const i = idx(tx,ty);
      const can = grid[i]===T_EMPTY && biomass>=RESIN_COST && adjacentConnectedResin(tx,ty);
      ctx.strokeStyle = can ? 'rgba(125,255,225,0.55)' : 'rgba(255,160,120,0.35)';
      ctx.lineWidth = 2;
      ctx.strokeRect(tx*TILE+2, ty*TILE+2, TILE-4, TILE-4);
    }

    // HUD
    const resinCount = countTiles(T_RESIN);
    const connCount = countConnectedResin();
    const connPct = resinCount ? Math.round((connCount/resinCount)*100) : 0;
    const aliveHosts = hosts.reduce((a,h)=>a+(h.alive?1:0),0);
    const totalMealworms = mealworms.reduce((a,m)=>a+(m.alive?1:0),0);
    const capturedMealworms = mealworms.reduce((a,m)=>a+((m.alive && m.captured)?1:0),0);
    const daylightPct = Math.round(daylightLevel * 100);
    const milkStat = mealwormMilk.toFixed(1);

    hudEl.innerHTML =
      `<b>BioHive</b> (original prototype)<br>` +
      `Biomass: <b>${biomass}</b> &nbsp; Drones: <b>${drones.length}</b> &nbsp; Eggs: <b>${eggs.length}</b> &nbsp; Hosts left: <b>${aliveHosts}</b><br>` +
      `Resin: <b>${connCount}</b> connected / <b>${resinCount}</b> total (<b>${connPct}%</b>) &nbsp; Patrol losses: <b>${kills}</b><br>` +
      `Mealworms penned: <b>${capturedMealworms}</b> / <b>${totalMealworms}</b> &nbsp; Milk yield: <b>${milkStat}</b> &nbsp; Daylight: <b>${daylightPct}%</b><br>` +
      `<span class="hint">WASD move, E pick/drop, Space drop, Right click place resin (cost ${RESIN_COST}), R reset</span><br>` +
      `<span class="warn">Tip: disconnected resin decays. Build outward in a single connected network.</span>`;
  }

  function adjacentConnectedResin(tx,ty) {
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for (const [dx,dy] of dirs){
      const nx=tx+dx, ny=ty+dy;
      if (!inb(nx,ny)) continue;
      const ni=idx(nx,ny);
      if (grid[ni]===T_RESIN && connected[ni]===1) return true;
    }
    return false;
  }

  function countTiles(type) {
    let c=0;
    for (let i=0;i<grid.length;i++) if (grid[i]===type) c++;
    return c;
  }
  function countConnectedResin() {
    let c=0;
    for (let i=0;i<grid.length;i++) if (grid[i]===T_RESIN && connected[i]===1) c++;
    return c;
  }

  // Start
  init();
  requestAnimationFrame(update);

  return { reset: init };
})();
const resetButton = document.getElementById('reset-run');
if (resetButton) {
  resetButton.addEventListener('click', () => bioHive.reset());
}

  </script>
</body>
</html>
